# -*- coding: utf-8 -*-
"""Q2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kJDJ_zUBSGgFzUXEIMJth0bpYuBzB-TW
"""

# generate 3 file:
#1) average_temp.txt
#2) largest_temp_range_station.txt
#3) temperature_stability_stations.txt
#
# Notes:
# checks and ignores missing values (NaN / empty)
# Seasons(Australia):
#Summer: Dec-Feb, Autumn: Mar-May, Winter: Jun-Aug, Spring: Sep-Nov

import os
import csv
import math

# month names matching file header
MONTHS = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
]

# season names according to the file
SEASONS = {
    "Summer": ["December", "January", "February"],
    "Autumn": ["March", "April", "May"],
    "Winter": ["June", "July", "August"],
    "Spring": ["September", "October", "November"],
}

STATION_COL = "STATION_NAME"

# checking missing values
def is_missing(value_str):
    if value_str is None:
        return True
    s = str(value_str).strip()
    if s == "":
        return True
    if s.lower() == "nan":
        return True
    return False

# handling missing values to float and None if missing
def to_float_or_none(value_str):

    if is_missing(value_str):
        return None
    try:
        return float(value_str)
    except ValueError:
        return None


def mean(values): #average of a list
    return sum(values) / len(values)



    """
    Population standard deviation:
    If only 1 value, stddev = 0.0.
    """
def pop_stddev(values):
    if len(values) <= 1:
        return 0.0
    m = mean(values)
    var = sum((x - m) ** 2 for x in values) / len(values)
    return math.sqrt(var)

    """
    Finds all CSV files inside a folder called 'temperatures'.
    If that folder does not exist, use the current folder as fallback.
    """
def find_csv_files():

    folder = "temperatures"
    if os.path.isdir(folder):
        base = folder
    else:
        base = "."  # fallback call

    csv_files = []
    for name in os.listdir(base):
        if name.lower().endswith(".csv"):
            csv_files.append(os.path.join(base, name))

    csv_files.sort()
    return csv_files


def process_all_files(csv_files):
    """
    Reads all CSV files and creates:
    1) Seasonal values across all stations and years
    2) each station list of all temperature values (all months, all years)
    """
    # seasonal average across ALL stations and ALL years
    season_values = {s: [] for s in SEASONS.keys()}

    # station range and station stability
    # station_temps[station_name] = [all temps across all files/months]
    station_temps = {}

    for path in csv_files:
        with open(path, "r", encoding="utf-8-sig", newline="") as f:
            reader = csv.DictReader(f)

            # missing column check
            if STATION_COL not in reader.fieldnames:
                raise ValueError("Missing required column: " + STATION_COL)

            # checks missing month and raises error
            for m in MONTHS:
                if m not in reader.fieldnames:
                    raise ValueError("Missing month column: " + m + " in file " + path)

            for row in reader:
                station = (row.get(STATION_COL) or "").strip()
                if station == "":
                    continue

                if station not in station_temps:
                    station_temps[station] = []

                # Collecting monthly temperatures for this row/station
                month_value = {}
                for m in MONTHS:
                    v = to_float_or_none(row.get(m))
                    month_value[m] = v
                    if v is not None:
                        station_temps[station].append(v)

                # Adding values to seasons (each month belongs to one season)
                for season_name, season_months in SEASONS.items():
                    for sm in season_months:
                        v = month_value.get(sm)
                        if v is not None:
                            season_values[season_name].append(v)

    return season_values, station_temps


    """
    Writes average temperature for each season to average_temp.txt
    example: Summer: 28.5C
    """
def write_seasonal_averages(season_values):
    with open("average_temp.txt", "w", encoding="utf-8") as out:
        for season_name in ["Summer", "Autumn", "Winter", "Spring"]:
            vals = season_values[season_name]
            if len(vals) == 0:
                out.write(season_name + ": No data\n")
            else:
                avg = mean(vals)
                out.write(f"{season_name}: {avg:.2f}C\n")

    """
    Finds station(s) with largest (max-min) across all values.
    Writes to largest_temp_range_station.txt
    """
def write_largest_range(station_temps):
    best_range = None
    best_list = []

    # Compute range for each station
    station_stats = {}  # station -> (min, max, range)
    for station, temps in station_temps.items():
        if len(temps) == 0:
            continue
        mn = min(temps)
        mx = max(temps)
        r = mx - mn
        station_stats[station] = (mn, mx, r)

        if best_range is None or r > best_range + 1e-12:
            best_range = r
            best_list = [station]
        elif abs(r - best_range) <= 1e-12:
            best_list.append(station)

    with open("largest_temp_range_station.txt", "w", encoding="utf-8") as out:
        if best_range is None:
            out.write("No data available.\n")
            return

        best_list.sort()
        for station in best_list:
            mn, mx, r = station_stats[station]
            out.write(f"{station}: Range {r:.2f}C (Max: {mx:.2f}C, Min: {mn:.2f}C)\n")


def write_stability(station_temps):
    """
    Finds most stable (smallest std dev) and most variable (largest std dev).
    Writes to temperature_stability_stations.txt
    """
    station_sd = []
    for station, temps in station_temps.items():
        if len(temps) == 0:
            continue
        sd = pop_stddev(temps)
        station_sd.append((station, sd))

    if len(station_sd) == 0:
        with open("temperature_stability_stations.txt", "w", encoding="utf-8") as out:
            out.write("No data available.\n")
        return

    min_sd = min(sd for _, sd in station_sd)
    max_sd = max(sd for _, sd in station_sd)

    most_stable = sorted([s for s, sd in station_sd if abs(sd - min_sd) <= 1e-12])
    most_variable = sorted([s for s, sd in station_sd if abs(sd - max_sd) <= 1e-12])

    with open("temperature_stability_stations.txt", "w", encoding="utf-8") as out:
        # List all ties
        for s in most_stable:
            out.write(f"Most Stable: {s}: StdDev {min_sd:.2f}C\n")
        for s in most_variable:
            out.write(f"Most Variable: {s}: StdDev {max_sd:.2f}C\n")


def main():
    csv_files = find_csv_files()
    if len(csv_files) == 0:
        print("No CSV files found.")
        print('Put all year CSV files into a folder named "temperatures", or in this folder.')
        return

    season_values, station_temps = process_all_files(csv_files)

    write_seasonal_averages(season_values)
    write_largest_range(station_temps)
    write_stability(station_temps)

    print("Done.")
    print("Created: average_temp.txt")
    print("Created: largest_temp_range_station.txt")
    print("Created: temperature_stability_stations.txt")


main()